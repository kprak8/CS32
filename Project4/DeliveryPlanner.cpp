#include "provided.h"
#include <vector>
using namespace std;

class DeliveryPlannerImpl
{
public:
    DeliveryPlannerImpl(const StreetMap* sm);
    ~DeliveryPlannerImpl();
    DeliveryResult generateDeliveryPlan(
        const GeoCoord& depot,
        const vector<DeliveryRequest>& deliveries,
        vector<DeliveryCommand>& commands,
        double& totalDistanceTravelled) const;
private:
    const StreetMap* myMap; //pointer to street map data
    PointToPointRouter myRouter;
    string findDirection(StreetSegment seg) const; //gives street seg's angle in the form of north, south, east or west
};

DeliveryPlannerImpl::DeliveryPlannerImpl(const StreetMap* sm) : myRouter(sm)
{
    myMap=sm;
}

DeliveryPlannerImpl::~DeliveryPlannerImpl()
{
}

DeliveryResult DeliveryPlannerImpl::generateDeliveryPlan(
    const GeoCoord& depot,
    const vector<DeliveryRequest>& deliveries,
    vector<DeliveryCommand>& commands,
    double& totalDistanceTravelled) const
{
    for ( int i = 0; i< deliveries.size(); i++){
        vector<StreetSegment> segs;
        //if any of the coordinates cannot be found, return bad coord
        if (!myMap->getSegmentsThatStartWith(depot, segs)|| !myMap->getSegmentsThatStartWith(deliveries[i].location, segs)){
            return BAD_COORD;
        }
    }
    
    vector<list<StreetSegment>> routesForEachDelivery;
    totalDistanceTravelled=0;
    double tempDist;
    
    //find the route from the depot to the first delivery if there is a path
    list<StreetSegment> route;
    route.clear();
    
    if (myRouter.generatePointToPointRoute(depot, deliveries[0].location, route, tempDist)==DELIVERY_SUCCESS){
        totalDistanceTravelled+=tempDist;
        routesForEachDelivery.push_back(route);
    }
    else{
        return NO_ROUTE;
    }
    
    //find the segments between each successive delivery after the first one from the depot if there is a path
    for ( int i = 0; i< deliveries.size(); i++){
        route.clear();
        //if it is the last delivery, find the route back to depot instead
        if (i==deliveries.size()-1){
            if(myRouter.generatePointToPointRoute(deliveries[i].location, depot, route, tempDist)==DELIVERY_SUCCESS){
                totalDistanceTravelled+=tempDist;
                routesForEachDelivery.push_back(route);
            }
            else{
                return NO_ROUTE;
            }
        }
        else{
            if(myRouter.generatePointToPointRoute(deliveries[i].location, deliveries[i+1].location, route, tempDist)==DELIVERY_SUCCESS){
                totalDistanceTravelled+=tempDist;
                routesForEachDelivery.push_back(route);
            }
            else{
                return NO_ROUTE;
            }
        }
    }
    
    //For each sequence of point-to-point StreetSegments generated by PointToPointRouter in
    //the previous step, generate a sequence of DeliveryCommands representing instructions to
    //the delivery robot.
    for (int j=0; j<routesForEachDelivery.size(); j++){
        list<StreetSegment> currRoute = routesForEachDelivery[j];
        list<StreetSegment>::iterator it;
        it=currRoute.begin();
        
        string currName = (*it).name;
        double currDist = 0;
        StreetSegment* prevSeg=nullptr;
        bool flag = false;
        while (it!=currRoute.end()){
           while ((*it).name==currName && it!=currRoute.end()){
                currDist+= distanceEarthMiles((*it).start, (*it).end);
                prevSeg = &(*it);
                it++;
               if(it==currRoute.end()){
                   flag=true;
               }
            }
            if (flag) break;
            
            //proceed on the street until the street name changes
            DeliveryCommand newCommand;
            string direction = findDirection(*prevSeg);
            newCommand.initAsProceedCommand(direction, prevSeg->name, currDist);
            commands.push_back(newCommand);
            // if angle is big enough between the next two segs, turn, else do nothing
            if (prevSeg!=nullptr){
                double angleBetweenTwo= angleBetween2Lines(*prevSeg, *it);
                if (angleBetweenTwo >= 1 && angleBetweenTwo <= 359 ){
                    DeliveryCommand turnCommand;
                    string dir;
                    if (angleBetweenTwo>= 1 && angleBetweenTwo < 180){
                        dir = "left";
                    }
                    else if (angleBetweenTwo >= 180 && angleBetweenTwo <= 359){
                        dir = "right";
                    }
                    turnCommand.initAsTurnCommand(dir, (*it).name);
                    commands.push_back(turnCommand);
                }
            }
            currName=(*it).name;
            prevSeg = &(*it);
            it++;
        }
        //deliver the food item
        DeliveryCommand deliverCommand;
        deliverCommand.initAsDeliverCommand(deliveries[j].item);
    }
    return DELIVERY_SUCCESS;
}

string DeliveryPlannerImpl::findDirection(StreetSegment seg) const {
    double angle = angleOfLine(seg);
    if ((0 <= angle && angle < 22.5)||angle >= 337.5)
        return "east";
    else if(22.5 <= angle && angle < 67.5)
        return "northeast";
    else if(67.5 <= angle && angle < 112.5)
        return "north";
    else if (112.5 <= angle && angle < 157.5)
        return "northwest";
    else if(157.5 <= angle && angle < 202.5)
        return "west";
    else if (202.5 <= angle && angle < 247.5)
        return "southwest";
    else if (247.5 <= angle && angle < 292.5)
        return "south";
    else if (292.5 <= angle && angle < 337.5)
        return "southeast";
    return "";
}


//******************** DeliveryPlanner functions ******************************

// These functions simply delegate to DeliveryPlannerImpl's functions.
// You probably don't want to change any of this code.

DeliveryPlanner::DeliveryPlanner(const StreetMap* sm)
{
    m_impl = new DeliveryPlannerImpl(sm);
}

DeliveryPlanner::~DeliveryPlanner()
{
    delete m_impl;
}

DeliveryResult DeliveryPlanner::generateDeliveryPlan(
    const GeoCoord& depot,
    const vector<DeliveryRequest>& deliveries,
    vector<DeliveryCommand>& commands,
    double& totalDistanceTravelled) const
{
    return m_impl->generateDeliveryPlan(depot, deliveries, commands, totalDistanceTravelled);
}
